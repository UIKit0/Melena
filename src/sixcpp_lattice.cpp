/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/lgpl.html>.
   
   Author:     Helge Mathee      helge.mathee@gmx.net
   Company:    Studio Nest (TM)
   Date:       2010 / 09 / 21
*/

// sixcpp_lattice Plugin
// Initial code generated by XSI SDK Wizard
// Executed Thu Dec 11 13:09:00 EST 2008 by hmathee
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_indexset.h>
#include <xsi_floatarray.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>
#include <xsi_doublearray.h>
#include <xsi_x3dobject.h>
#include <xsi_primitive.h>
#include <xsi_selection.h>
#include <xsi_customoperator.h>
#include <xsi_ppglayout.h>
#include <xsi_menu.h>
#include <xsi_menuitem.h>
#include <xsi_polygonmesh.h>
#include <xsi_operatorcontext.h>
#include <xsi_iceattribute.h>
#include <xsi_iceattributedataarray.h>
#include <xsi_iceattributedataarray2D.h>

// Defines port, group and map identifiers used for registering the ICENode
enum Array_IDs
{
   Array_ID_IN_Vector = 0,
   Array_ID_G_100 = 100,
   Array_ID_OUT_Result = 200,
   Array_ID_G_300 = 300,
   Array_ID_TYPE_CNS = 400,
   Array_ID_STRUCT_CNS,
   Array_ID_CTXT_CNS,
   Array_ID_UNDEF = ULONG_MAX
};
enum Lattice_IDs
{
   Lattice_ID_IN_Point = 0,
   Lattice_ID_IN_Subdivision = 1,
   Lattice_ID_IN_Step = 2,
   Lattice_ID_IN_Reference = 3,
   Lattice_ID_IN_Current = 4,
   Lattice_ID_G_100 = 100,
   Lattice_ID_OUT_Result = 200,
   Lattice_ID_G_300 = 300,
   Lattice_ID_TYPE_CNS = 400,
   Lattice_ID_STRUCT_CNS,
   Lattice_ID_CTXT_CNS,
   Lattice_ID_UNDEF = ULONG_MAX
};

XSI::CStatus Register_nest_ArrayNode( XSI::PluginRegistrar& in_reg );
XSI::CStatus Register_nest_LatticeNode( XSI::PluginRegistrar& in_reg );

using namespace XSI; 
using namespace MATH;

XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
   in_reg.PutAuthor(L"hmathee");
   in_reg.PutName(L"sixcpp_lattice Plugin");
   in_reg.PutEmail(L"");
   in_reg.PutURL(L"");
   in_reg.PutVersion(1,0);

   Register_nest_ArrayNode( in_reg );
   Register_nest_LatticeNode( in_reg );

   return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
   CString strPluginName;
   strPluginName = in_reg.GetName();
   Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
   return CStatus::OK;
}

CStatus Register_nest_ArrayNode( PluginRegistrar& in_reg )
{
   ICENodeDef nodeDef;
   nodeDef = Application().GetFactory().CreateICENodeDef(L"nest_GetPositionArray");

   CStatus st;

	st = nodeDef.PutThreadingModel(XSI::siICENodeSingleThreading);
	st.AssertSucceeded( ) ;

   // Add input ports and groups.
   st = nodeDef.AddPortGroup(Array_ID_G_100);
   st.AssertSucceeded( ) ;

   st = nodeDef.AddInputPort(Array_ID_IN_Vector,Array_ID_G_100,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextAny,L"Vector",L"Vector",CVector3f(0,0,0),Array_ID_UNDEF,Array_ID_UNDEF,Array_ID_CTXT_CNS);
   st.AssertSucceeded( ) ;

   // Add output ports and groups.
   st = nodeDef.AddPortGroup(Array_ID_G_300);
   st.AssertSucceeded( ) ;

   st = nodeDef.AddOutputPort(Array_ID_OUT_Result,Array_ID_G_300,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextSingleton,L"Array",L"Array",Array_ID_UNDEF,Array_ID_UNDEF,Array_ID_UNDEF);
   st.AssertSucceeded( ) ;

   PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
   nodeItem.PutCategories(L"Array");

   return CStatus::OK;
}

CStatus Register_nest_LatticeNode( PluginRegistrar& in_reg )
{
   ICENodeDef nodeDef;
   nodeDef = Application().GetFactory().CreateICENodeDef(L"nest_LatticeDeform");

   CStatus st;

	st = nodeDef.PutThreadingModel(XSI::siICENodeMultiThreading);
	st.AssertSucceeded( ) ;

   // Add input ports and groups.
   st = nodeDef.AddPortGroup(Lattice_ID_G_100);
   st.AssertSucceeded( ) ;

   st = nodeDef.AddInputPort(Lattice_ID_IN_Point,Lattice_ID_G_100,siICENodeDataVector3,siICENodeStructureAny,siICENodeContextAny,L"Point",L"Point",CVector3f(0,0,0),Lattice_ID_UNDEF,Lattice_ID_STRUCT_CNS,Lattice_ID_CTXT_CNS);
   st.AssertSucceeded( ) ;
   st = nodeDef.AddInputPort(Lattice_ID_IN_Subdivision,Lattice_ID_G_100,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextSingleton,L"Subdivision",L"Subdivision",CVector3f(1,1,1),Lattice_ID_UNDEF,Lattice_ID_UNDEF,Lattice_ID_UNDEF);
   st.AssertSucceeded( ) ;
   st = nodeDef.AddInputPort(Lattice_ID_IN_Step,Lattice_ID_G_100,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextSingleton,L"Step",L"Step",CVector3f(1,1,1),Lattice_ID_UNDEF,Lattice_ID_UNDEF,Lattice_ID_UNDEF);
   st.AssertSucceeded( ) ;
   st = nodeDef.AddInputPort(Lattice_ID_IN_Reference,Lattice_ID_G_100,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextSingleton,L"References",L"References",CVector3f(1,1,1),Lattice_ID_UNDEF,Lattice_ID_UNDEF,Lattice_ID_UNDEF);
   st.AssertSucceeded( ) ;
   st = nodeDef.AddInputPort(Lattice_ID_IN_Current,Lattice_ID_G_100,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextSingleton,L"Currents",L"Currents",CVector3f(1,1,1),Lattice_ID_UNDEF,Lattice_ID_UNDEF,Lattice_ID_UNDEF);
   st.AssertSucceeded( ) ;

   // Add output ports and groups.
   st = nodeDef.AddPortGroup(Lattice_ID_G_300);
   st.AssertSucceeded( ) ;

   st = nodeDef.AddOutputPort(Lattice_ID_OUT_Result,Lattice_ID_G_300,siICENodeDataVector3,siICENodeStructureAny,siICENodeContextAny,L"Deform",L"Deform",Lattice_ID_UNDEF,Lattice_ID_STRUCT_CNS,Lattice_ID_CTXT_CNS);
   st.AssertSucceeded( ) ;

   PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
   nodeItem.PutCategories(L"Custom ICENode");

   return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus nest_GetPositionArray_Evaluate( ICENodeContext& in_ctxt )
{
   // The current output port being evaluated...
   ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );

   switch( out_portID )
   {
      case Array_ID_OUT_Result:
      {
         // Get the output port array ...
         CDataArray2DVector3f outData( in_ctxt );

         // Get the input data buffers for each port
         CDataArrayVector3f InData( in_ctxt, Array_ID_IN_Vector );

         // We need a CIndexSet to iterate over the data
         LONG count = InData.GetCount();
         outData.Resize(0,InData.GetCount());

         for(LONG i=0;i<count;i++)
            outData[0][i] = InData[i];
      }
      break;

      // Other output ports...

   };

   return CStatus::OK;
}

long clampl(long a, long b, long c)
{
	if(a < b)
		return b;
	if(a > c)
		return c;
	return a;
}

float clampf(float a, float b, float c)
{
	if(a < b)
		return b;
	if(a > c)
		return c;
	return a;
}

long compose(long x, long y, long z, long yres, long zres)
{
	return x * yres * zres + y * zres + z;
}

XSIPLUGINCALLBACK CStatus nest_LatticeDeform_Evaluate( ICENodeContext& in_ctxt )
{
   // The current output port being evaluated...
   ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );

   switch( out_portID )
   {
      case Array_ID_OUT_Result:
      {
         siICENodeDataType dataType;
         siICENodeStructureType struType;
         siICENodeContextType contType;
         in_ctxt.GetPortInfo(Lattice_ID_IN_Point,dataType,struType,contType);
			
         // get all of the data that is the same for any structure
         CDataArrayVector3f SubdivData( in_ctxt, Lattice_ID_IN_Subdivision );
         CDataArrayVector3f StepData( in_ctxt, Lattice_ID_IN_Step );
         CDataArray2DVector3f ReferenceData( in_ctxt, Lattice_ID_IN_Reference );
         CDataArray2DVector3f CurrentData( in_ctxt, Lattice_ID_IN_Current );
         CDataArray2DVector3f::Accessor ReferenceDataSub = ReferenceData[0];
         CDataArray2DVector3f::Accessor CurrentDataSub = CurrentData[0];

         // define the things we need to calculate
         long subdiv[3];
         subdiv[0] = long(floor(SubdivData[0].GetX()));
         subdiv[1] = long(floor(SubdivData[0].GetY()));
         subdiv[2] = long(floor(SubdivData[0].GetZ()));
         long subdiv1[3];
         subdiv1[0] = subdiv[0]+1;
         subdiv1[1] = subdiv[1]+1;
         subdiv1[2] = subdiv[2]+1;
         float step[3];
         step[0] = 1.0f / StepData[0].GetX();
         step[1] = 1.0f / StepData[0].GetY();
         step[2] = 1.0f / StepData[0].GetZ();
			float steplength = StepData[0].GetLength();
         long indexX[8];
         long indexY[8];
         long indexZ[8];
         long index[8];
         long lastIndex[3];
			lastIndex[0] = -1;
			lastIndex[1] = -1;
			lastIndex[2] = -1;
			CVector3f posCp;
			CVector3f pos;
         CVector3f diff[8];
         CVector3f motion[8];
         CVector3f motionScl[8];
			CVector3f deform;
         float weight[8];
			float xyz0[3];
			float xyz1[3];
			float weightSum;
         
         if(struType == siICENodeStructureSingle)
         {
            // two behaviours based on the datatype...
            // Get the output port array ...
            CDataArrayVector3f outData( in_ctxt );
   
            // Get the input data buffers for each port
            CDataArrayVector3f PointData( in_ctxt, Lattice_ID_IN_Point );

            // iterate each subset!
            CIndexSet IndexSet( in_ctxt );
            for(CIndexSet::Iterator it = IndexSet.Begin(); it.HasNext(); it.Next())
            {
               // first let's find the index inside the box!
					posCp.Set(PointData[it].GetX(),PointData[it].GetY(),PointData[it].GetZ());
					
					// substract the lowest corner
					pos.Sub(posCp,ReferenceDataSub[0]);
					pos.Set(pos.GetX() * step[0], pos.GetY() * step[1], pos.GetZ() * step[2]);
					xyz0[0] = pos.GetX() - floor(pos.GetX());
					xyz0[1] = pos.GetY() - floor(pos.GetY());
					xyz0[2] = pos.GetZ() - floor(pos.GetZ());

					xyz1[0] = 1.0 - xyz0[0];
					xyz1[1] = 1.0 - xyz0[1];
					xyz1[2] = 1.0 - xyz0[2];
					
					// calculate the indices (decomposed)
					indexX[0] = clampl(long(floor(pos.GetX())),0,subdiv[0]);
					indexY[0] = clampl(long(floor(pos.GetY())),0,subdiv[1]);
					indexZ[0] = clampl(long(floor(pos.GetZ())),0,subdiv[2]);
					
					if(lastIndex[0] != indexX[0] || lastIndex[1] != indexY[0] || lastIndex[2] != indexZ[0])
					{
						indexX[1] = clampl(indexX[0]+1	,0,subdiv[0]);
						indexY[1] = clampl(indexY[0]	,0,subdiv[1]);
						indexZ[1] = clampl(indexZ[0]	,0,subdiv[2]);
	
						indexX[2] = clampl(indexX[0]+1	,0,subdiv[0]);
						indexY[2] = clampl(indexY[0]+1	,0,subdiv[1]);
						indexZ[2] = clampl(indexZ[0]	,0,subdiv[2]);
	
						indexX[3] = clampl(indexX[0]+1	,0,subdiv[0]);
						indexY[3] = clampl(indexY[0]	,0,subdiv[1]);
						indexZ[3] = clampl(indexZ[0]+1	,0,subdiv[2]);
	
						indexX[4] = clampl(indexX[0]+1	,0,subdiv[0]);
						indexY[4] = clampl(indexY[0]+1	,0,subdiv[1]);
						indexZ[4] = clampl(indexZ[0]+1	,0,subdiv[2]);
						
						indexX[5] = clampl(indexX[0]	,0,subdiv[0]);
						indexY[5] = clampl(indexY[0]+1	,0,subdiv[1]);
						indexZ[5] = clampl(indexZ[0]	,0,subdiv[2]);
	
						indexX[6] = clampl(indexX[0]	,0,subdiv[0]);
						indexY[6] = clampl(indexY[0]	,0,subdiv[1]);
						indexZ[6] = clampl(indexZ[0]+1	,0,subdiv[2]);
	
						indexX[7] = clampl(indexX[0]	,0,subdiv[0]);
						indexY[7] = clampl(indexY[0]+1	,0,subdiv[1]);
						indexZ[7] = clampl(indexZ[0]+1	,0,subdiv[2]);
						
						for(int i=0;i<8;i++)
						{
							// compose the indices!
							index[i] = compose(indexX[i],indexY[i],indexZ[i],subdiv1[1],subdiv1[2]);
							
							// calculate the motions
							motion[i].Sub(CurrentDataSub[index[i]],ReferenceDataSub[index[i]]);
						}
					}
					else
					{
						// for performance, remember the last used index
						lastIndex[0] = indexX[0];
						lastIndex[1] = indexY[0];
						lastIndex[2] = indexZ[0];
					}

					// compute the weights
					weight[0] = xyz1[0] * xyz1[1] * xyz1[2];
					weight[1] = xyz0[0] * xyz1[1] * xyz1[2];
					weight[2] = xyz0[0] * xyz0[1] * xyz1[2];
					weight[3] = xyz0[0] * xyz1[1] * xyz0[2];
					weight[4] = xyz0[0] * xyz0[1] * xyz0[2];
					weight[5] = xyz1[0] * xyz0[1] * xyz1[2];
					weight[6] = xyz1[0] * xyz1[1] * xyz0[2];
					weight[7] = xyz1[0] * xyz0[1] * xyz0[2];

					// sum up all weighted motions
					deform.SetNull();
					for(int i=0;i<8;i++)
					{
						motionScl[i].Scale(weight[i],motion[i]);
						deform.AddInPlace(motionScl[i]);
					}
					
					// output the deformed position
					outData[it] = deform;
            }
         }
			else
         {
            // two behaviours based on the datatype...
            // Get the output port array ...
            CDataArray2DVector3f outData( in_ctxt );
   
            // Get the input data buffers for each port
            CDataArray2DVector3f PointData( in_ctxt, Lattice_ID_IN_Point );

            // iterate each subset!
            CIndexSet IndexSet( in_ctxt );
            for(CIndexSet::Iterator it = IndexSet.Begin(); it.HasNext(); it.Next())
            {
		         CDataArray2DVector3f::Accessor PointDataSub = PointData[it];
					long subCount = PointDataSub.GetCount();
					Application().LogMessage(CString((LONG)subCount));
					outData.Resize(it,subCount);
					for(long k=0;k<subCount;k++)
					{
						// first let's find the index inside the box!
						posCp.Set(PointDataSub[k].GetX(),PointDataSub[k].GetY(),PointDataSub[k].GetZ());
						
						// substract the lowest corner
						pos.Sub(posCp,ReferenceDataSub[0]);
						pos.Set(pos.GetX() * step[0], pos.GetY() * step[1], pos.GetZ() * step[2]);
						xyz0[0] = pos.GetX() - floor(pos.GetX());
						xyz0[1] = pos.GetY() - floor(pos.GetY());
						xyz0[2] = pos.GetZ() - floor(pos.GetZ());
	
						xyz1[0] = 1.0 - xyz0[0];
						xyz1[1] = 1.0 - xyz0[1];
						xyz1[2] = 1.0 - xyz0[2];
						
						// calculate the indices (decomposed)
						indexX[0] = clampl(long(floor(pos.GetX())),0,subdiv[0]);
						indexY[0] = clampl(long(floor(pos.GetY())),0,subdiv[1]);
						indexZ[0] = clampl(long(floor(pos.GetZ())),0,subdiv[2]);
						
						if(lastIndex[0] != indexX[0] || lastIndex[1] != indexY[0] || lastIndex[2] != indexZ[0])
						{
							indexX[1] = clampl(indexX[0]+1	,0,subdiv[0]);
							indexY[1] = clampl(indexY[0]	,0,subdiv[1]);
							indexZ[1] = clampl(indexZ[0]	,0,subdiv[2]);
		
							indexX[2] = clampl(indexX[0]+1	,0,subdiv[0]);
							indexY[2] = clampl(indexY[0]+1	,0,subdiv[1]);
							indexZ[2] = clampl(indexZ[0]	,0,subdiv[2]);
		
							indexX[3] = clampl(indexX[0]+1	,0,subdiv[0]);
							indexY[3] = clampl(indexY[0]	,0,subdiv[1]);
							indexZ[3] = clampl(indexZ[0]+1	,0,subdiv[2]);
		
							indexX[4] = clampl(indexX[0]+1	,0,subdiv[0]);
							indexY[4] = clampl(indexY[0]+1	,0,subdiv[1]);
							indexZ[4] = clampl(indexZ[0]+1	,0,subdiv[2]);
							
							indexX[5] = clampl(indexX[0]	,0,subdiv[0]);
							indexY[5] = clampl(indexY[0]+1	,0,subdiv[1]);
							indexZ[5] = clampl(indexZ[0]	,0,subdiv[2]);
		
							indexX[6] = clampl(indexX[0]	,0,subdiv[0]);
							indexY[6] = clampl(indexY[0]	,0,subdiv[1]);
							indexZ[6] = clampl(indexZ[0]+1	,0,subdiv[2]);
		
							indexX[7] = clampl(indexX[0]	,0,subdiv[0]);
							indexY[7] = clampl(indexY[0]+1	,0,subdiv[1]);
							indexZ[7] = clampl(indexZ[0]+1	,0,subdiv[2]);
							
							for(int i=0;i<8;i++)
							{
								// compose the indices!
								index[i] = compose(indexX[i],indexY[i],indexZ[i],subdiv1[1],subdiv1[2]);
								
								// calculate the motions
								motion[i].Sub(CurrentDataSub[index[i]],ReferenceDataSub[index[i]]);
							}
						}
						else
						{
							// for performance, remember the last used index
							lastIndex[0] = indexX[0];
							lastIndex[1] = indexY[0];
							lastIndex[2] = indexZ[0];
						}
	
						// compute the weights
						weight[0] = xyz1[0] * xyz1[1] * xyz1[2];
						weight[1] = xyz0[0] * xyz1[1] * xyz1[2];
						weight[2] = xyz0[0] * xyz0[1] * xyz1[2];
						weight[3] = xyz0[0] * xyz1[1] * xyz0[2];
						weight[4] = xyz0[0] * xyz0[1] * xyz0[2];
						weight[5] = xyz1[0] * xyz0[1] * xyz1[2];
						weight[6] = xyz1[0] * xyz1[1] * xyz0[2];
						weight[7] = xyz1[0] * xyz0[1] * xyz0[2];
	
						// sum up all weighted motions
						deform.SetNull();
						for(int i=0;i<8;i++)
						{
							motionScl[i].Scale(weight[i],motion[i]);
							deform.AddInPlace(motionScl[i]);
						}
						
						// output the deformed position
						outData[it][k] = deform;
					}
				}
         }
      }
      break;

      // Other output ports...

   };

   return CStatus::OK;
}
